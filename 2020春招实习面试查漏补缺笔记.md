# 2020春招实习面试查漏补缺笔记

### 1. 抽象类和接口是否有默认实现

接口只有定义，不能有方法的实现；抽象类可以有定义与实现，方法可在抽象类中实现



### 2. 线程安全与线程不安全，线程不安全的例子

线程安全：多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性。

线程不安全：不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

**线程不安全实例**

假如A有两张一模一样的银行卡（账户一样，余额一样），假如卡上余额1000块，而A跟B同时在不同的ATM上面取1000块钱（理想中的同时），如果线程不安全，那么俩人都能同时取出1000块。而如果线程安全的话，只能一个人同时操作一个账户，当这个账户正在被操作时，是被锁起来的，不给别人动的，只能你自己动，你动完了别人才能动。

**为什么会有线程安全问题**

线程安全问题都是由全局变量及静态变量引起的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。



### 3. Java内存结构

Java把内存分为栈内存、堆内存、方法区、本地方法区和寄存器等



### 4. Ajax简介

AJAX = 异步 JavaScript 和 XML。

AJAX 是一种用于创建快速动态网页的技术。

通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。



### 5. DOM简介

DOM是W3C的标准，DOM定义了访问HTML和XML文档的标准，DOM是Document Object Model文档对象模型的缩写。

HTML DOM是①HTML的标准对象模型、②HTML的标准编程接口、③W3C标准

HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。



### 6. 数据库相关

**6.1 怎么查看创建表的语句**

```mysql
show create table tb_name
```

**6.2 MySQL分页查询**

```mysql
select * from tb_name limit m offset n
```

表示输出m条数据，跳过n条数据，从第(n+1)条数据开始输出

**6.3 SQL注入**

①定义

SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。

②构造

在用户名输入框中输入:' or 1=1#,密码随便输入，可以成功登录。

“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了

```mysql
select * from users where username='' or 1=1#' and password=md5('') 
select * from users where usrername='' or 1=1
```

PHP万能密码

```mysql
select * from users where username='admin'#' and password=md5('')
select * from users where username='admin'
```

③预防措施

- 输入验证：确信输入的内容只包含合法的数据
- 输入转义：每个DBMS都有一个字符转义机制告知DBMS输入的是数据而不是代码
- 最小权限法：基于用户需要什么样的权限进行分配
- 参数化查询：数据库服务器不会将参数的内容视为SQL指令的一部分来处理
- 错误消息处理：错误消息可能会暴露一些敏感信息被攻击者利用
- 加密处理：将用户登录名，密码等数据加密保存

**6.4 什么是索引，索引的优缺点，索引的类型**

定义：索引是对数据库表中一个或多个列的值进行排序的结构

优点：①加快数据的检索速度、②创建唯一性索引保证数据库表中每一行数据的唯一性、③加速表和表之间的连接，在实现数据的参考完整性方面有意义

缺点：①创建和维护索引要耗费时间、②索引占物理空间、③对表中数据进行增加、删除和修改时，索引要动态维护，降低了数据维护速度

分类：①唯一索引：索引列的值必须唯一，但允许有空值、②主键索引：特殊的唯一索引，不允许有空值、③普通索引、④组合索引：最左前缀原则，设a,b,c上建立联合索引，会用到索引的情况有a,b,c和a,b和a、⑤全文索引：只能用于MyISAM类型数据表，只能用于CHAR、VARCHAR、TEXT数据类型

**6.5 什么是事务**

定义：单个逻辑工作单元执行的一系列操作（对数据库的相关CRUD操作），要么完全地执行，要么完全地不执行。

**6.6 模糊查询**

```mysql
select * from table where xxx like xxxxxx
```

%：任意0个或多个字符

_：任意单个字符

[ ] : 括号内所列字符中的一个，可指定字符串或范围，如[1-5]、[一二三]四五

[^ ] ：不在括号所列之内的单个字符

**6.7 数据库MVCC**

MVCC(Multiversion Concurrency Control)，多版本并发控制技术。使大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库并发控制，而是讲行锁和行的多个版本结合起来，只需要很小开销就可以实现非锁定读，大大提高数据库系统并发性能。

①MVCC解决的问题

- MVCC实现了MySQL中第三级事务隔离级别，可重复读
- 锁机制可以控制并发操作单系统开销大，MVCC可代替行锁，降低开销

②MVCC实现原理

- MVCC是保存数据在某个时间点的快照实现的，典型的有乐观并发控制和悲观并发控制
- InnoDB MVCC主要是为可重复读事务隔离级别做的

③MVCC具体实现

InnoDB的MVCC是通过在数据库表的后面加入两个隐藏列来实现的，分别保存了这个行的创建时间，一个保存的是行的删除时间。开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID

④MVCC在执行select、delete、insert、update的过程

- SELECT

能返回查询结果，需要满足以下标准：

a)InnoDB只查找版本早于当前事务版本的数据行（数据行的版本必须小于等于事务的版本），确保当前事务读取的行都是事务之前已经存在的或由当前事务创建或修改的行

b)行的删除版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有被删除

- INSERT

InnoDB为每个新增行记录当前系统版本号作为创建ID

- DELETE

InnoDB为每个删除行记录当前系统版本号作为行的删除ID

- UPDATE

InnoDB复制了一行，这个新行的版本号使用了系统版本号，它也把系统版本号作为了删除行的版本

**6.8 case...when语句**

```mysql
case 
  when sex = '1' then '男'
  when sex = '2' then '女'
else '未知' end
```

case when相当于一个自定义的数据透视表，group by是行名，case when负责列名

🔺分组查询及格人数和不及格人数

```mysql
select score as 类别,count(*) as 人数 from
(select case when score>=60 then '及格' else '不及格' end as score from stu )
stu group by score
```

**6.9 创建与原有表结构相同的空白表**

```mysql
select * into 新表 from 旧表 where 1<>1
```

**6.10 MySQL 日期时间**

表示时间值的数据类型

| 类型      | 格式                | 大小  |
| --------- | ------------------- | ----- |
| DATE      | YYYY-MM-DD          | 3字节 |
| TIME      | HH:MM:SS            | 3字节 |
| YEAR      | YYYY                | 1字节 |
| DATETIME  | YYYY-MM-DD HH:MM:SS | 8字节 |
| TIMESTAMP | YYYYMMDD HHMMSS     | 4字节 |

DATE_FORMAT日期格式化

```mysql
select date_format(now(),"%Y-%m-%d %H:%i:%s")
```

TIME_FORMAT时间格式化

```mysql
SELECT TIME_FORMAT(NOW(),'%H:%i:%s')
```

UNIX_TIMESTAMP

```mysql
select unix_timestamp(now())
-- '1585841322'
```

计算年份、月份、天数、小时、分钟

```mysql
-- 前2年
select year(date_sub(now(),interval 2 year))
-- 下个月
select month(date_sub(now(),interval -1 month))
-- 前一天
select day(date_sub(now(),interval 1 day))
-- 20分钟后的分钟数
select minute(date_sub(now(),interval -20 minute))
-- 前3小时
select hour(date_sub(now(),interval 3 hour))
```

**6.11 count(1)、count(*)、count(字段）**

count(字段)：对特定的列的值具有的行数进行计算，不包含null值

count(1)和count(*)：效率差不多，对行的数目计算，包含null值

**6.12 MySQL的连接**

```mysql
# 查看最大连接数
show variables like "max_connections"
# 查询相关连接
show status like "Threads%"
-- 返回信息如下：
Threads_created:已经创建的连接数
Threads_connected:已经连接的连接数
Threads_running:活跃连接数（没有sleep的连接数）
```



### 7. Linux相关

**7.1 基础命令**

df：以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息(df -h)

du：显示磁盘空间的使用情况，用于查看当前目录的总大小

su：切换用户(su root)

chmod：修改文件权限(chmod 774 file_name)、User：7（r：4+w：2+x：1）、Group：7、Other：4

管道 |：①管道是一种通信方式（IPC机制），把一个程序的输出直接连接到另一个程序的输入，常说的是无名管道，只能用于具有亲缘关系的进程之间，这是与有名管道（named pipe或FIFO）最大区别

②管道的本质是**内存中的缓冲区**，可看作是打开到内存中的文件，需要使用两个文件描述符来索引它，一个表示读端，一个表示写端，**数据只能从读端读取，只能往写端写入**

top：查看CPU使用率、查看内存使用率

free：查看内存使用率

sed：文件处理，以行为单位进行处理，将数据替换、删除、新增、选取等操作

**7.2 查看某个字符串在文件中出现的次数**

```shell
grep 'abc' a.txt | wc -l
```

**7.3 grep和find**

grep：根据文件内容查找

find：根据文件属性查找，如文件名，文件大小等

如：找出以A开头的文件：

```shell
find -name 'A*'
```

**7.4 sed文件处理**

```shell
sed '1d' a.txt	//删除第一行
sed '2,$d' a.txt	//删除第二行到最后一行
sed -n '1p' a.txt	//显示第一行
sed -n '2,$p' a.txt	//显示第二行到最后一行
sed '1a abcdefg' a.txt	//第一行后（第一行和第二行之间）插入字符串abcdefg
```

**7.5 scp上传本地文件到服务器或下载服务器文件到本地**

```bash
scp path/filename userName@serverName:path // 将本地文件上传到服务器
scp userName@serverName:path path/filename // 下载服务器文件到本地
```

如果操作的是文件夹需要加上 `-r` 参数，使用递归上传或者下载



### 8. Java语言相关

**8.1 abstract与static能否共存**

①用static声明方法表明这个方法在不生成类的实例时可直接被类调用，而abstract方法不能被调用，两者矛盾。

②static修饰的方法不能被重写，abstract修饰的方法可以被重写。

**8.2 字符串比较**

```java
public class MyClass{
    public static void main(String[]args) {
        String str1 = new String("test");
        String str2 = "test";
        String str3 = "t"+"est";
        System.out.println(str1==str2);//false
        System.out.println(str2==str3);//true
        System.out.println(str1.intern()==str2);//true
    }
}
```

- 表达式右边只有字符串常量，就把变量存放在常量池中
- new出来的字符串存放在堆内存里
- 字符串拼接操作：右边如果存在字符串引用，就存放在堆内存中，如果是纯字符串常量就存放在栈里

**8.3 重写、重载与多态**

| 区别     | 重载方法 | 重写方法                                   |
| -------- | -------- | ------------------------------------------ |
| 参数列表 | 必须修改 | 一定不能修改                               |
| 返回类型 | 可以修改 | 一定不能修改                               |
| 异常     | 可以修改 | 可以减少或删除，不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 不能做更严格的限制（可以降低限制）         |

方法重载是多态的具体表现形式，重写是父类与子类之间多态性的一种表现

多态存在的三个必要条件：①继承、②重写、③父类引用指向子类对象

**8.4 static**

①static修饰成员方法

对于静态方法，是没有this的，因为它不依附于任何对象

在静态方法中不能访问类的非静态成员变量和非静态成员方法

在非静态方法中可以访问静态成员方法/变量

🔺想在不创建对象情况下调用某个方法，可以将这个方法设置为static，最常见的static方法就是main方法，因为程序在执行main方法时没有创建任何对象，因此只有通过类名来访问。

②static修饰成员变量

静态变量被所有对象共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化

非静态变量是对象拥有的，在创建对象时被初始化，存在多个副本，各个对象拥有的副本互不影响

③static修饰代码块

static块可放于类中任意地方，类中可以有多个static块。在类初次被加载时，会按照static块顺序来依次执行每个static块，并且只会执行一次。static块可优化程序性能。

④使用static注意的地方

- static不会改变变量和方法的访问权限
- 虽然对于静态方法没有this，但在非静态方法中能通过this访问静态方法成员变量
- 不允许使用static修饰局部变量

⑤static成员变量的生命周期

- 加载：JVM在加载类的过程中为静态变量分配内存
- 类变量：static变量在内存中只有一个，存放在方法区，属于类变量
- 销毁：类被卸载时，静态变量被销毁，并释放内存空间

🔺static变量的生命周期取决于类的生命周期

补充：类初始化顺序：静态变量、静态代码块初始化 ----> 构造函数 ------>自定义构造函数



### 9. lambda表达式

lambda表达式用来定义一个匿名函数

**python**

```python
func = lambda x, y:x*y
print(func(2,7))	# 14
func2 = lambda  :100
print(func2())	# 100
```



### 10. C++、Java、Python是编译型语言还是解释型语言

编译型：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序（C++）

解释型：把做好的源程序翻译一句，然后执行一句，直至结束！（Java、Python）



### 11. 计算机网络相关

**11.1  127.0.0.1是什么地址**

127.0.0.1是回送地址，指本地机，一般用来测试使用。

回送地址（127.x.x.x）是本机回送地址，即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信。

无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。

可用 `ping 127.0.0.1`在本机上做回路测试，验证本机的TCP/IP协议簇是否被正确安装

**11.2 HTTP状态码**

| 状态码                  | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 503 Service Unavailable | 由于超载或系统维护，服务器暂时无法处理客户端的请求           |
| 501 Not Implemented     | 服务器不支持请求的功能，无法完成请求                         |
| 401 Unauthorized        | 请求要求用户的身份认证                                       |
| 303 See Other           | 查看其他地址                                                 |
| 304 Not Modified        | 未修改。所请求的资源未修改，服务器返回此状态码时不会返回任何资源。 |
| 502 Bad Gateway         | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |
| 504 Gateway Timeout     | 充当网关或代理的服务器，未及时从远端服务器获取请求           |

**11.3 TCP拥塞控制**

网络拥塞：对网络中某一资源（带宽、交换节点中的缓存和处理机等）的需求超过了该资源所能提供的可用部分，网络性能变坏。

四种算法：

①慢开始

发送方维护一个拥塞窗口cwnd，先发送一个字节，然后发送两个字节、四个字节（指数增长速率）

②拥塞避免

增长速率变为线性增长，每经过一个往返时间RTT就把发送方的cwnd加1

③快重传

收到3个冗余ACK包，可能是报文丢失，发送方不执行慢开始，直接快重传，立即发送缺失的报文段

④快恢复

将ssthresh调整为此时cwnd一半，执行拥塞避免算法

⭐在连接建立开始到连接终止这个过程中，TCP传输的速率需要流量控制和拥塞控制，共同调整发送方窗口，最终发送方发送窗口上限值为Min（rwnd，cwnd）。拥塞控制主要调控发送方的网络负载和吞吐量的相对大小，从慢开始（指数增长）、拥塞避免算法（线性增长）一直增大速率，算法切换条件为慢开始门限值ssthresh：①若出现超时，ssthresh = cwnd/2，cwnd=1（之后执行慢开始）、②若出现3个冗余ACK，ssthresh = cwnd/2，cwnd = ssthresh（之后执行拥塞避免），直至连接结束。

**11.4 HTTP报文**

①HTTP请求报文

由请求行、请求头部、空行和请求数据4部分组成

- 请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，之间空格分隔，例如：GET /index.html HTTP/1.1

  🔺请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

  HEAD：类似GET，服务端接受到HEAD请求后只返回响应头而不会发送响应内容。当只需查看某页面状态时用HEAD非常高效。

- 请求头部：由关键字/值对组成，每行一对，关键字和值用英文冒号 : 分割。请求头部通知服务器有关于客户端请求的信息。

  🔺典型请求头：

  User-Agent：产生请求的浏览器类型

  Accept：客户端可识别的内容类型列表

  Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机

- 空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头

- 请求数据：不在GET方法使用，而在POST方法使用。POST方法适用于需要客户填写表单场景，与请求数据相关的最常用请求头是Content-Type和Content-Length

②HTTP响应报文

由状态行、消息报头、响应正文三部分组成

状态行格式例如：HTTP-Version Status-Code Reason-Phrase CRLF

HTTP-Version：服务器HTTP协议版本

Status-Code：状态码

Reason-Phrase：状态代码的文本描述

**11.5 IP数据报格式**

由首部和数据部分组成，首部又分为固定部分和可变部分

- 首部的固定部分（20字节）

  版本、长度、区分服务、总长度、标识、标志、片偏移、生存时间、协议（6表示TCP协议、17表示UDP协议）、首部校验和、源地址、目的地址

- 首部的可变部分（1-40字节）

  可选字段（增加IP数据报功能，如用来排错、测量以及安全等措施）、填充

**11.6 TCP报文格式**

包括源端口、目的端口、序号和确认号、数据偏移、保留、URG、ACK、PSH、RST、SYN、FIN、窗口、校验和、紧急指针、选项和填充、数据部分

**11.7 UDP报文格式**

源端口号、目的端口号、UDP长度、UDP检验和、数据（如有）

**11.8 HTTP/1.0/1.1/2.0 **

HTTP1.0使用短连接

HTTP1.1使用长连接，有效减少TCP的三次握手开销

HTTP2.0使用新的二进制解析格式，多路复用连接共享、header压缩

**11.9 HTTPS**

HTTPS协议 = HTTP协议+SSL/TLS协议

HTTPS为兼顾安全与效率，同时使用对称加密和非对称加密。对数据进行对称加密，对称加密所使用的密钥通过非对称加密传输。



### 12. 数据结构和算法相关

**12.1 哈希冲突解决措施**

①开放定址法：线性探测、二次探测、伪随机探测

②链地址法

③再哈希法

④建立公共溢出区



### 13. 操作系统相关

**13.1 虚拟内存**

虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）

实际它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝

虚拟页存储在磁盘上，物理页缓存在DRAM中

**13.2 进程拥有什么资源、同一进程不同线程之间的资源共享和独享**

线程共享的环境：进程代码段、进程的公有数据、进程打开的文件描述符、信号处理器、进程的当前目录和进程用户ID与进程组ID、堆

线程独占的资源：线程ID、寄存器组的值、错误返回码、线程的优先级、栈

**13.3 什么是端口，什么是套接字（Socket）**

端口：①物理意义上的端口：集线器、交换机、路由器用于连接其他网络设备的端口

②逻辑意义上的端口，一般指TCP/IP协议中的端口，端口号范围0——65535（周知端口：0-1023、动态端口：1024-65535）

端口的作用：IP地址与网络服务是一对多关系，用“IP地址+端口号”区分不同服务（HTTP\FTP\SMTP)

套接字：包含源IP地址和源端口号、目的IP地址和目的端口号。用于标识客户端请求的服务器和服务

| 协议   | 端口号                 |
| ------ | ---------------------- |
| SMTP   | 25                     |
| Telnet | 23                     |
| HTTP   | 80                     |
| FTP    | 控制连接20、数据连接21 |
| DNS    | 53                     |
| HTTPS  | 443                    |
| POP3   | 110                    |
| DHCP   | 服务器67、客户端68     |



### 14. 场景题

**14.1 网页突然加载不出来的原因**

网络断开、后端页面无法加载、网页被劫持、DNS无法解析网址、服务器负载过大、供应商网络出口出现问题

**14.2 微信抢红包 测试用例设计**

```
功能测试：
1.红包钱数、红包个数输入框只能输入数字
2.当红包钱数超过最大范围或发送的红包个数超过最大范围是否有提示
3.当余额不足时，红包发送失败
4.发送的红包别人是否可以领取
5.红包金额里小数位数是否有限制
6.支付成功后，退回聊天界面
7.支付时可以密码支付也可以指纹支付
8.余额不足时，会不会自动匹配支付方式
9.24小时内没有领取的红包是否可以退回到原来账户
10.用户是否可以多次抢一个红包
性能测试：
1.弱网时抢红包，发红包时间
2.退款到账时间
3.收发红包的耗电量
4.发红包和收红包成功后的跳转时间
5.不同网速时抢发红包的时间
兼容性测试：
1.iOS、Android是否都可以发送红包
2.电脑端是否可以抢发红包
界面UI测试：
1.发红包界面是否有错别字
2.抢完红包界面是否有错别字
3.收红包和发红包界面排版合理
4.收红包和发红包界面颜色搭配合理
可用性测试：
1.红包描述，是否支持语音输入
2.多支付方式可用
安全性测试：
1.红包发送成功，是否会受到微信支付通知
2.发送红包失败，余额和银行卡里钱数不会少
3.红包被领取之后，发红包人金额减少、收红包人金额增加
4.对方微信号异地登录，是否会有提醒
```

**14.3 海量数据处理（Top K）**

①分而治之/Hash映射+HashMap统计+堆/快速/归并排序

求前k大，用最小堆、求前k小，用最大堆

⭐堆排序java实现代码：

```java
    private static void heapSort(int[] arr) {
        for (int i = (arr.length - 1) / 2; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }
        for (int i = arr.length - 1; i > 0; i--) {
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, i);
        }
    }
    
    private static void adjustHeap(int[] arr, int parent, int length) {
        int temp = arr[parent];
        int lChild = 2 * parent + 1;

        while (lChild < length) {
            int rChild = lChild + 1;
            if (rChild < length && arr[lChild] < arr[rChild]) {
                lChild++;
            }
            if (temp >= arr[lChild]) {
                break;
            }
            arr[parent] = arr[lChild];
            parent = lChild;
            lChild = 2 * lChild + 1;
        }
        arr[parent] = temp;
    }
```

②多层划分

③Bloom filter/Bitmap

④Trie树/数据库/倒排索引

⑤外排序

⑥分布式处理之Map-Reduce



### 15. 智力题

**15.1  1+11+111+1111+......+1111...11(2009个1）结果中有多少个1**

从低位到高位，先加个位，再加十位，再加百位，以此类推

个位求的和值%10得到个位的值，/10得到进位

例如：

个位求和：2009,个位数9，2009/10=200，就是进位十位的值

十位求和：2008+200=2208，十位就是2208%10=8，进位是2208/10=220

百位求和：2007+220=2207，十位就是2207%10=7，进位是2207/10=220

**15.2 一个4分钟沙漏和一个7分钟沙漏，怎么量出9分钟时间**

设7分钟沙漏为A，4分钟沙漏为B

A,B同时漏，4分钟后，状态为A（3，4）、B（0，4）

B反过来，A漏完之后，状态为A（0，7）、B（1，3）

A反过来，B漏完之后，状态为A（1，6）、B（0，4）

A反过来，1分钟后，状态为A（0，7）、B（0，4）

**15.3 为什么下水道盖子是圆的**

正方形的对角线是其边长的约1.414倍。如果把一个正方形盖子垂直地立起来，稍微一转，它就会很容易掉到下水道里去。与此相反，圆的直径都是等长的，这使它很难掉进去。

